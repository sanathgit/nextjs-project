Introduction
====================================================
Styling: The different ways to style your application in Next.js.
Optimizations: How to optimize images, links, and fonts.
Routing: How to create nested layouts and pages using file-system routing.
Data Fetching: How to set up a Postgres database on Vercel, and best practices for fetching and streaming.
Search and Pagination: How to implement search and pagination using URL search params.
Mutating Data: How to mutate data using React Server Actions, and revalidate the Next.js cache.
Error Handling: How to handle general and 404 not found errors.
Form Validation and Accessibility: How to do server-side form validation and tips for improving accessibility.
Authentication: How to add authentication to your application using NextAuth.js and Proxy.
Metadata: How to add metadata and prepare your application for social sharing.

Getting Started
================================================================================
use pnpm as package manager. More effecient than npm or yarn
To create the project 
npx create-next-app@latest nextjs-dashboard --example "https://github.com/vercel/next-learn/tree/main/dashboard/starter-example" --use-pnpm

place holder data
Use a 3rd party service like mockAPI.

For this project, we've provided some placeholder data in app/lib/placeholder-data.ts. Each JavaScript object in the file represents a table in your database.

Typescript
If you're a TypeScript developer:

We're manually declaring the data types, but for better type-safety, we recommend Prisma or Drizzle, which automatically generates types based on your database schema.
Next.js detects if your project uses TypeScript and automatically installs the necessary packages and configuration. Next.js also comes with a TypeScript plugin for your code editor, to help with auto-completion and type-safety.

Running the development server
pnpm -i
pnpm dev
================================================================================
Chapter 2 - Styling
How to add a global CSS file to your application.
Two different ways of styling: Tailwind and CSS modules.
How to conditionally add class names with the clsx utility package.

import '@/app/ui/global.css'
If you prefer writing traditional CSS rules or keeping your styles separate from your JSX - CSS Modules are a great alternative.
CSS Modules create unique class names for each component, so you don't have to worry about style collisions.
The file should be named as file.module.css

import styles from '@/app/ui/file.module.css';
<div className={styles.shape} />
Tailwind and CSS modules are the two most common ways of styling Next.js applications. Whether you use one or the other is a matter of preference - you can even use both in the same application!

clsx is a library that lets you toggle class names easily. We recommend taking a look at documentation for more details.

Other styling solutions
Sass which allows you to import .css and .scss files.
CSS-in-JS libraries such as styled-jsx, styled-components, and emotion.

================================================================================
Chapter 3 - Optimizing Fonts and images
How to add custom fonts with next/font.
How to add images with next/image.
How fonts and images are optimized in Next.js.

Fonts play a significant role in the design of a website, but using custom fonts in your project can affect performance if the font files need to be fetched and loaded.

Cumulative Layout Shift is a metric used by Google to evaluate the performance and user experience of a website. With fonts, layout shift happens when the browser initially renders text in a fallback or system font and then swaps it out for a custom font once it has loaded. This swap can cause the text size, spacing, or layout to change, shifting elements around it.

Next.js automatically optimizes fonts in the application when you use the next/font module. It downloads font files at build time and hosts them with your other static assets. 

create a new file called fonts.ts.
Import the Inter font from the next/font/google module - this will be your primary font. Then, specify what subset you'd like to load. In this case, 'latin':

import { Inter } from 'next/font/google';
export const inter = Inter({ subsets: ['latin'] });

Import the font
import { inter } from '@/app/ui/fonts';
<body className={`${inter.className} antialiased`}>{children}</body>


Next.js can serve static assets, like images, under the top-level /public folder. 

However, this means you have to manually:

Ensure your image is responsive on different screen sizes.
Specify image sizes for different devices.
Prevent layout shift as the images load.
Lazy load images that are outside the user's viewport.

Image Optimization is a large topic in web development that could be considered a specialization in itself. Instead of manually implementing these optimizations, you can use the next/image component to automatically optimize your images.

The <Image> Component is an extension of the HTML <img> tag, and comes with automatic image optimization, such as:

Preventing layout shift automatically when images are loading.
Resizing images to avoid shipping large images to devices with a smaller viewport.
Lazy loading images by default (images load as they enter the viewport).
Serving images in modern formats, like WebP and AVIF, when the browser supports it.

Set the width and height of your images to avoid layout shift, these should be an aspect ratio identical to the source image. 
Images without dimensions and web fonts are common causes of layout shift due to the browser having to download additional resources.

LOT OF RECOMMENDED READINGS - PLEASE VISIT
================================================================================
Chapter 4 - Creating Layouts and Pages

Create the dashboard routes using file-system routing.
Understand the role of folders and files when creating new route segments.
Create a nested layout that can be shared between multiple dashboard pages.
Understand what colocation, partial rendering, and the root layout are.

Next.js uses file-system routing where folders are used to create nested routes. Each folder represents a route segment that maps to a URL segment.
page.tsx is a special Next.js file that exports a React component, and it's required for the route to be accessible.
create a new route segment using a folder, and add a page file inside it.
By having a special name for page files, Next.js allows you to colocate UI components, test files, and other related code with your routes. Only the content inside the page file will be publicly accessible.

In Next.js, you can use a special layout.tsx file to create UI that is shared between multiple pages.
One benefit of using layouts in Next.js is that on navigation, only the page components update while the layout won't re-render. This is called partial rendering which preserves client-side React state in the layout when transitioning between pages.

root layout is required in every Next.js application. Any UI you add to the root layout will be shared across all pages in your application.
================================================================================
Chapter 5 - Navigating between pages
How to use the next/link component.
How to show an active link with the usePathname() hook.
How navigation works in Next.js.

In Next.js, you can use the <Link /> Component to link between pages in your application. <Link> allows you to do client-side navigation with JavaScript.

Automatic code-splitting and prefetching
To improve the navigation experience, Next.js automatically code splits your application by route segments. This is different from a traditional React SPA, where the browser loads all your application code on the initial page load.
Splitting code by routes means that pages become isolated. If a certain page throws an error, the rest of the application will still work. This is also less code for the browser to parse, which makes your application faster.

In production, whenever <Link> components appear in the browser's viewport, Next.js automatically prefetches the code for the linked route in the background.
Next.js provides a hook called usePathname() that you can use to check the path and implement this pattern.
================================================================================
Chapter 6 - Setting up your Database
Push your project to GitHub.
Set up a Vercel account and link your GitHub repo for instant previews and deployments.
Create and link your project to a Postgres database.
Seed the database with initial data.

Create a Github Repository
You can also use other git providers like GitLab or Bitbucket.
If you're new to GitHub, we recommend the GitHub Desktop App for a simplified development workflow.

Add files to Github Repository
git init
git add .
git commit -m "Initial commit"
git remote add origin nextjs-project
git push -u origin main
